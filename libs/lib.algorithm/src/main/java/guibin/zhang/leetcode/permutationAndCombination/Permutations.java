package guibin.zhang.leetcode.permutationAndCombination;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 
 * Given a collection of numbers, return all possible permutations.
 * 
 * For example,
 * [1,2,3] have the following permutations:
 * [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
 * 
 * http://yucoding.blogspot.com/2013/04/leetcode-question-69-permutations.html
 * http://blog.csdn.net/tuantuanls/article/details/8717262
 * http://discuss.leetcode.com/questions/224/permutations
 * 
 * 
 * @author Gubin Zhang <guibin.beijing@gmail.com>
 */
public class Permutations {
    
    /**
     * The idea of this classic problem is to use backtracking.
     * We want to get permutations, which is mainly about swap values in the list.
     * Consider:
     * a --> a
     * ab --> ab, ba
     * abc --> abc, acb, bac, bca, cab, cba.
     * ...
     * where for the length of n, the permutations can be generated by
     * (1) Swap the 1st element with all the elements, including itself.
     * (2) Then the 1st element is fixed, go to the next element.
     * (3) Until the last element is fixed. Output.
     * It's more clear in the figure above. The key point is to make the big problem into smaller problem, 
     * here is how to convert the length n permutation into length n-1 permutation problem.
     * 
     * @param num
     * @return 
     */
    public List<List<Integer>> permute_v3(int[] num) {
        // Start typing your Java solution below
        // DO NOT write main() function
        if(num == null) return null;
        
        //Initialize the branch to be permuted.
        Integer[] branch = new Integer[num.length];
        for (int i = 0; i < num.length; i++) {
            branch[i] = num[i];
        }
        
        List<List<Integer>> result = new ArrayList<>();
        perm(branch, 0, num.length - 1, result);
        return result;
        
    }
    
    /**
     * swap the elements from start to end, one by one. 
     * 
     * Permutation swap version
     * Basically it is a recursive swapping algorithm.
     * 
     * Actually it is not in order, but it is **close to the sorted order**.
     * 
     * How do you permute a three-letter string? Well, the permuations are
     * 1. The first letter followed by the permutions of the second and third letters.
     * 2. The second letter followed by the permutions of the first and third letters.
     * 3. The third letter followed by the permutions of the first and second letters.
     * 
     * So the algorithm is:
     * 1. Keep the first letter constant and do all the permutations of the second and third letters (printing out the entire string each time).
     * 2. Swap the original first and second letters of the string, and repeat step 1 for the new string.
     * 3. Swap the original first and third letters of the string, and repeat step 1 for the new string.
     * 
     * General algorithm
     * For an N-letter string it's a bit like:
     * for (i=0; i < N; ++i)
     *     Swap letters 0 and i.
     *     Permute letters 1 to N-1, printing out the entire string each time.
     * 
     * @param branch The input array to be permuted.
     * @param start The start position to be permuted.
     * @param end The end position to be permuted.
     * @param result 
     */
    public void perm(Integer[] branch, int start, int end, List<List<Integer>> result) {
        if (start == end) {
            result.add(new ArrayList<>(Arrays.asList(branch)));
            return;
        } 
        for (int i = start; i <= end; i++) {
            //Swap the first element with the rest of the element, including itself.
            swap(branch, start, i);
            perm(branch, start + 1, end, result);
            //Swap back
            swap(branch, start, i);
        }
    }
    
    private void swap(Integer[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
    
    /**
     * http://gourabmitra.blogspot.com/2012/05/permutations-of-string-by-recursion.html
     * https://www.youtube.com/watch?v=MQcwxQK2DPA
     * 
     * Assume that you have a function f() which returns the permutations of a given string and 
     * let’s pass an argument string “abc” to it. 
     * So for the current argument  string, print the letters one by one and 
     * make recursive call over rest of the string except the current letter. 
     * 
     * The algorithm proceeds as,
     * 
     * f(“abc”) = “a” + f(“bc”) and “b” + f(“ac”) and “c” + f(“ab”)
     * f(“bc”) = “b” + f(“c”) and “c” + f(”b”)
     * f(“ac”) = “a” + f(“c”) and “c” + f(“a”)
     * f(“ab”) = “a” + f(“b”) and “b” + f(“a”)
     * f(“a”) = “a” + f(“”)  ;  f(“b”) = “b” + f(“”) ;  f(“c”) = “c” + f(“”)
     * f(“”) = base condition. no more recursive calls.
     * 
     * n! = n * (n-1)!
     * 
     * The result is **in lexicographic order**.
     * 
     * @param beginning
     * @param ending
     */
    public void permute(String beginning, String ending) {
        
        if(ending.length() <= 1) {
            System.out.println(beginning + ending);
        } else {
            for (int i = 0; i < ending.length(); i++) {
                //Current character is removed from ending in order to generate the new ending, which is pasted to f().
                String nEnding = ending.substring(0, i) + ending.substring(i + 1);
                permute(beginning + ending.charAt(i), nEnding);
            }
        }
    }
    
    
    /**
     * Same algorithm with above. it is also **in lexicographic order**.
     * 
     * @param beginning
     * @param ending
     * @param result 
     */
    public void permute(String beginning, String ending, List<String> result) {
        
        if(ending.length() <= 1) {
            result.add(beginning + ending);
        } else {
            for(int i = 0; i < ending.length(); i++) {
                String nEnding = ending.substring(0, i) + ending.substring(i + 1);
                permute(beginning + ending.charAt(i), nEnding, result);
            }
        }
    }
    
    public void permute(List<Integer> beginning, List<Integer> ending, List<List<Integer>> result) {
        if(ending.size() <= 1) {
            List<Integer> row = new ArrayList<>();
            row.addAll(new ArrayList<>(beginning));
            row.addAll(new ArrayList<>(ending));
            result.add(row);
        } else {
            for (int i = 0; i < ending.size(); i++) {
                List<Integer> nBeginning = new ArrayList<>(beginning);
                List<Integer> nEnding = new ArrayList<>(ending);
                nEnding.remove(i);
                nBeginning.add(ending.get(i));
                permute(nBeginning, nEnding, result);
            }
        }
    }
    
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
        // Start typing your Java solution below
        // DO NOT write main() function
        if (num == null) {
            return null;
        }
        return permute(num, num.length - 1);
    }
    
    //The result is not in order, totally disorder. 
    public ArrayList<ArrayList<Integer>> permute(int[] num, int k) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        if (k < 0) {
            result.add(new ArrayList<Integer>());
        } else {
            for (ArrayList<Integer> x : permute(num, k - 1)) {
                for (int i = 0; i <= x.size(); i++) {
                    ArrayList<Integer> tmp = (ArrayList<Integer>) x.clone();
                    tmp.add(i, num[k]);
                    result.add(tmp);
                }
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        Permutations pt = new Permutations();
        
        int[] num3 = {0, 1, 2, 3};
        ArrayList<ArrayList<Integer>> result5 = pt.permute(num3);
        System.out.println("----permute----");
        for(ArrayList<Integer> list : result5) {
            for(Integer i : list) {
                System.out.print(i);
            }
            System.out.println();
        }
        
        
        int[] num = {0, 1, 2, 3};
        List<List<Integer>> result = pt.permute_v3(num);
        System.out.println("----permute_v3----");
        for(List<Integer> list : result) {
            for(Integer i : list) {
                System.out.print(i);
            }
            System.out.println();
        }
        
        System.out.println("^^--------^^");
        List<String> result2 = new ArrayList<String>();
        pt.permute("", "abcd", result2);
        for(String str : result2) {
            System.out.println(str);
        }
        
        List<Integer> ending = new ArrayList<>();
        ending.add(0);
        ending.add(1);
        ending.add(2);
        ending.add(3);
        List<Integer> beginning = new ArrayList<>();
        List<List<Integer>> result3 = new ArrayList<>();
        pt.permute(beginning, ending, result3);
        System.out.println("^^^^^^^^^^^^");
        for(List<Integer> list : result3) {
            for (int i : list) {
                System.out.print(i);
            }
            System.out.println();
        }
    }
}
